(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Lines"] = factory();
	else
		root["Lines"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./lib/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./lib/calc-base.js":
/*!**************************!*\
  !*** ./lib/calc-base.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar store = __webpack_require__(/*! ./store */ \"./lib/store.js\");\n\nvar utils = __webpack_require__(/*! ./utils */ \"./lib/utils.js\");\n\nvar _require = __webpack_require__(/*! ./config */ \"./lib/config.js\"),\n    cfg = _require.config;\n\nvar CalcBase =\n/*#__PURE__*/\nfunction () {\n  function CalcBase() {\n    _classCallCheck(this, CalcBase);\n  }\n\n  _createClass(CalcBase, [{\n    key: \"start\",\n    value: function start() {\n      this.init();\n      this.initSteps();\n    }\n  }, {\n    key: \"main\",\n    value: function main() {\n      this.lines();\n      this.candle();\n      this.sma();\n      this.ema();\n    } // min, max & attitude\n    // toDo if candle is set check whole data\n    // else use init2 only with close value\n\n  }, {\n    key: \"init\",\n    value: function init() {\n      var ohlcData = store.get(\"raw\");\n\n      var first = _toConsumableArray(ohlcData[0]);\n\n      first.pop();\n      var init = {\n        len: ohlcData.length,\n        min: Math.min.apply(Math, _toConsumableArray(first)),\n        minLine: Math.min.apply(Math, _toConsumableArray(first)),\n        max: Math.max.apply(Math, _toConsumableArray(first)),\n        maxLine: Math.max.apply(Math, _toConsumableArray(first)),\n        amplitude: 0,\n        zero: first[3]\n      };\n      ohlcData.forEach(function (item) {\n        //get min from low or close\n        if (init.min > item[2]) init.min = item[2];\n        if (init.min > item[3]) init.min = item[3]; //get max from high or close\n\n        if (init.max < item[1]) init.max = item[1];\n        if (init.max < item[3]) init.max = item[3];\n        if (init.minLine > item[3]) init.minLine = item[3];\n        if (init.maxLine < item[3]) init.maxLine = item[3];\n      });\n      init.amplitude = utils.f(init.max - init.min);\n      this.save(init);\n    } // min, max & attitude\n\n  }, {\n    key: \"init2\",\n    value: function init2() {\n      var data = store.get(\"data\");\n      var init = {\n        len: data.length,\n        min: data[0],\n        max: data[0],\n        amplitude: 0,\n        zero: data[0]\n      };\n      data.forEach(function (item) {\n        if (init.min > item) init.min = item;\n        if (init.max < item) init.max = item;\n      });\n      init.amplitude = utils.f(init.max - init.min);\n      this.save(init);\n    } // stepX, stepY, zeroX & zeroY\n\n  }, {\n    key: \"initSteps\",\n    value: function initSteps() {\n      var _store$mget = store.mget([\"area\", \"amplitude\", \"len\", \"zero\", \"min\"]),\n          area = _store$mget.area,\n          amplitude = _store$mget.amplitude,\n          len = _store$mget.len,\n          zero = _store$mget.zero,\n          min = _store$mget.min;\n\n      var stepX = 0,\n          stepY = 0,\n          zeroX = 0,\n          zeroY = 0;\n      stepX = utils.f(area.width / len, 0);\n      stepY = utils.f(area.height / amplitude, 0);\n      zeroX = area.zeroX;\n      zeroY = utils.f(area.zeroY - (zero - min) * stepY, 0);\n      this.save({\n        stepX: stepX,\n        stepY: stepY,\n        zeroX: zeroX,\n        zeroY: zeroY\n      });\n    }\n  }, {\n    key: \"lines\",\n    value: function lines() {\n      var data = store.get(\"data\");\n      store.set(\"points\", this.dataToPoints(data), \"line\");\n    }\n    /**\r\n     * dataToPoints\r\n     *  - convert values to axis Points\r\n     * @param {Array} dataArray - array of digit values\r\n     * @example [1.23, 1.47, 1.3] => [[30,360], [90, 300], [150, 320]]\r\n     * @returns {Array} points - axis points\r\n     */\n\n  }, {\n    key: \"dataToPoints\",\n    value: function dataToPoints() {\n      var dataArray = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      var _store$mget2 = store.mget([\"stepX\", \"stepY\", \"zeroX\", \"zeroY\"]),\n          stepX = _store$mget2.stepX,\n          stepY = _store$mget2.stepY,\n          zeroX = _store$mget2.zeroX,\n          zeroY = _store$mget2.zeroY;\n\n      var prev = {\n        data: dataArray[0],\n        point: [zeroX, zeroY]\n      };\n      return dataArray.map(function (data, k) {\n        if (!k) {\n          return prev.point; // point 0\n        } // can be negative\n\n\n        var diff = (data - prev.data) * stepY; // [ xAxis, yAxis ]\n\n        var point = [prev.point[0] + stepX, utils.f(prev.point[1] - diff, 0)];\n        prev = {\n          data: data,\n          point: point\n        };\n        return point;\n      });\n    }\n  }, {\n    key: \"yAxis\",\n    value: function yAxis() {\n      var _store$mget3 = store.mget([\"amplitude\", \"area\", \"min\"]),\n          amplitude = _store$mget3.amplitude,\n          area = _store$mget3.area,\n          min = _store$mget3.min;\n\n      var totalGrids = cfg.chart.totalGrids;\n      var labelDiff = utils.f(amplitude * (1 / totalGrids), 7);\n      return {\n        xAxis: area.zeroX,\n        yAxis: area.zeroY,\n        label: min,\n        labelDiff: labelDiff\n      };\n    } // split into categories ... lines, candles, smas, emas ...\n\n  }, {\n    key: \"save\",\n    value: function save(storeData) {\n      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"line\";\n\n      if (_typeof(storeData) === \"object\") {\n        store.mset(storeData);\n      }\n    }\n  }, {\n    key: \"candle\",\n    value: function candle() {\n      var _this = this;\n\n      var _store$mget4 = store.mget([\"stepX\", \"stepY\", \"raw\"]),\n          stepX = _store$mget4.stepX,\n          stepY = _store$mget4.stepY,\n          ohlcData = _store$mget4.raw;\n\n      var points = store.get(\"points\", \"line\");\n      var candleFill = cfg.chart.candleFill;\n      var candleWidth = utils.f(stepX * candleFill, 0);\n      points.forEach(function (point, idx) {\n        if (idx > 0) {\n          var linePoints = {\n            prevPoint: points[idx - 1],\n            point: point\n          };\n\n          _this.candleBody(linePoints, {\n            candleWidth: candleWidth,\n            stepX: stepX,\n            stepY: stepY,\n            ohlc: {\n              Open: ohlcData[idx][0],\n              High: ohlcData[idx][1],\n              Low: ohlcData[idx][2],\n              Close: ohlcData[idx][3]\n            }\n          });\n        }\n      });\n    } // candle = candleBody + candleShadow\n    // return candleBody {x, y, width, height, xCenter}\n\n  }, {\n    key: \"candleBody\",\n    value: function candleBody(linePoints, storeData) {\n      // prev & current point\n      var prevPoint = linePoints.prevPoint,\n          point = linePoints.point;\n      var candleWidth = storeData.candleWidth,\n          stepX = storeData.stepX;\n      var candle = {\n        x: 0,\n        y: point[1] > prevPoint[1] ? prevPoint[1] : point[1],\n        width: candleWidth,\n        height: Math.abs(point[1] - prevPoint[1]),\n        xCenter: utils.f(point[0] - stepX / 2, 0),\n        isWin: prevPoint[1] > point[1] ? true : false\n      };\n      candle.x = utils.f(candle.xCenter - candleWidth / 2, 0);\n      this.candleShadow(linePoints, storeData, candle);\n    }\n    /**\r\n     * candleShadow\r\n     *  - top & bottom vertical line\r\n     * @param {Object} linePoints - line axis points\r\n     * @param {Object} storeData - data from store\r\n     * @param {Object} candleBody - calculated values from candleBody\r\n     */\n\n  }, {\n    key: \"candleShadow\",\n    value: function candleShadow(linePoints, storeData, candleBody) {\n      var prevPoint = linePoints.prevPoint,\n          point = linePoints.point;\n      var stepY = storeData.stepY,\n          _storeData$ohlc = storeData.ohlc,\n          Open = _storeData$ohlc.Open,\n          High = _storeData$ohlc.High,\n          Low = _storeData$ohlc.Low,\n          Close = _storeData$ohlc.Close;\n      var yAxis = candleBody.y,\n          xCenter = candleBody.xCenter,\n          isWin = candleBody.isWin;\n      var shadow = {\n        top: [[xCenter, yAxis], [xCenter, yAxis]],\n        bottom: [[xCenter, prevPoint[1]], [xCenter, prevPoint[1]]],\n        isWin: isWin\n      };\n      var diffTop, diffBot;\n\n      if (isWin) {\n        diffTop = High - Close;\n        diffBot = Open - Low;\n      } else {\n        diffTop = High - Open;\n        diffBot = Close - Low; //change both yAxis !!!\n\n        shadow.bottom[0][1] = point[1];\n        shadow.bottom[1][1] = point[1];\n      }\n\n      shadow.top[1][1] -= utils.f(diffTop * stepY, 0);\n      shadow.bottom[1][1] += utils.f(diffBot * stepY, 0);\n      store.push(\"candle.points\", _objectSpread({}, candleBody, {}, shadow));\n    }\n  }]);\n\n  return CalcBase;\n}();\n\nmodule.exports = CalcBase;\n\n//# sourceURL=webpack://Lines/./lib/calc-base.js?");

/***/ }),

/***/ "./lib/calc.js":
/*!*********************!*\
  !*** ./lib/calc.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar store = __webpack_require__(/*! ./store */ \"./lib/store.js\");\n\nvar utils = __webpack_require__(/*! ./utils */ \"./lib/utils.js\");\n\nvar _require = __webpack_require__(/*! ./config */ \"./lib/config.js\"),\n    cfg = _require.config;\n\nvar CalcBase = __webpack_require__(/*! ./calc-base */ \"./lib/calc-base.js\");\n\nvar Calc =\n/*#__PURE__*/\nfunction (_CalcBase) {\n  _inherits(Calc, _CalcBase);\n\n  function Calc() {\n    _classCallCheck(this, Calc);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Calc).apply(this, arguments));\n  }\n\n  _createClass(Calc, [{\n    key: \"sma\",\n    //move in separate file - sma + ema...\n    // SMA = (A1 + A2 + ... An) / n\n    // 1 + 2 + 3 + 4 + 5 / 5\n    value: function sma() {\n      var smaLen = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2;\n      var data = store.get(\"data\");\n      var smaData = this.calcSma(data, smaLen);\n      store.mset({\n        data: smaData,\n        points: this.dataToPoints(smaData)\n      }, \"sma\");\n    } // return sma data\n\n  }, {\n    key: \"calcSma\",\n    value: function calcSma(dataArray, smaLen) {\n      var total = 0;\n      return dataArray.map(function (d, idx) {\n        ++idx; // start from 1 not 0\n\n        total += d; // increase\n\n        if (idx > smaLen) {\n          total -= dataArray[idx - 1 - smaLen]; // decrease\n        }\n\n        return idx < smaLen ? d : utils.f(total / smaLen);\n      });\n    }\n  }, {\n    key: \"ema\",\n    value: function ema() {\n      var emaLen = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2;\n      var data = store.get(\"data\");\n      var emaData = this.calcEma(data, emaLen);\n      store.mset({\n        data: emaData,\n        points: this.dataToPoints(emaData)\n      }, \"ema\");\n    } // EMA(today) = Price(today) * K + EMA(yesterday) * (1-K)\n    // EMAtoday = Ptoday * k + EMAyest * k2\n    // K = 2 / (length + 1)\n\n  }, {\n    key: \"calcEma\",\n    value: function calcEma(dataArray, emaLen) {\n      var k = 2 / (emaLen + 1);\n      var k2 = 1 - k;\n      var prev = dataArray[0];\n      return dataArray.map(function (d, idx) {\n        if (!idx) return d;\n        var edata = d * k + prev * k2;\n        prev = d;\n        return utils.f(edata);\n      });\n    }\n  }, {\n    key: \"findY\",\n    value: function findY(x) {\n      var yPixel = this.findYpixel(x);\n\n      if (!yPixel) {\n        return false;\n      }\n\n      var _store$mget = store.mget([\"zeroY\", \"stepY\", \"minLine\"]),\n          zeroY = _store$mget.zeroY,\n          stepY = _store$mget.stepY,\n          minLine = _store$mget.minLine;\n\n      var yValue = minLine + (zeroY - yPixel) / stepY;\n      return {\n        pixel: yPixel,\n        value: utils.f(yValue)\n      };\n    } // find line slope between two points\n\n  }, {\n    key: \"findYpixel\",\n    value: function findYpixel(xValue) {\n      var points = store.get(\"points\", \"line\");\n      var pointIdx = points.findIndex(function (point) {\n        return point[0] > xValue;\n      });\n\n      if (!pointIdx || pointIdx < 1) {\n        return;\n      }\n\n      var _ref = [points[pointIdx - 1], points[pointIdx]],\n          point = _ref[0],\n          point1 = _ref[1]; // slope = (y2 - y1) / (x2 - x1);\n\n      var slope = (point1[1] - point[1]) / (point1[0] - point[0]); // b = y1 - (slope * x1);\n\n      var b = point[1] - slope * point[0];\n      return slope * xValue + b;\n    }\n  }]);\n\n  return Calc;\n}(CalcBase);\n\nmodule.exports = Calc;\n\n//# sourceURL=webpack://Lines/./lib/calc.js?");

/***/ }),

/***/ "./lib/chart-base.js":
/*!***************************!*\
  !*** ./lib/chart-base.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar store = __webpack_require__(/*! ./store */ \"./lib/store.js\");\n\nvar utils = __webpack_require__(/*! ./utils */ \"./lib/utils.js\");\n\nvar _require = __webpack_require__(/*! ./config */ \"./lib/config.js\"),\n    cfg = _require.config;\n\nvar ChartBase =\n/*#__PURE__*/\nfunction () {\n  function ChartBase(elemId, calcInstance) {\n    _classCallCheck(this, ChartBase);\n\n    if (!window.getComputedStyle) {\n      return;\n    }\n\n    this.el = this.getId(elemId);\n    this.snap = window.Snap(\"#\" + elemId);\n    this.group = this.snap.group();\n    this.calc = calcInstance;\n    this.init();\n  }\n\n  _createClass(ChartBase, [{\n    key: \"init\",\n    value: function init() {\n      var elemStyle = window.getComputedStyle(this.el);\n      var width = utils.f(elemStyle.width, 0);\n      var height = utils.f(elemStyle.height, 0);\n      var chartHeight = height - cfg.chart.padding * 2;\n      this.area = {\n        w: width,\n        h: height,\n        width: width - cfg.chart.padding * 2,\n        height: chartHeight,\n        endX: width - cfg.chart.padding,\n        zeroX: cfg.chart.padding,\n        zeroY: height - cfg.chart.padding,\n        offsetLeft: this.el.offsetLeft || this.el.parentElement.offsetLeft || 0,\n        offsetTop: this.el.offsetTop || this.el.parentElement.offsetTop || 0,\n        gridStep: utils.f(chartHeight / cfg.chart.totalGrids, 0) // yAxis\n\n      };\n      store.set(\"area\", this.area);\n    }\n  }, {\n    key: \"drawAxis\",\n    value: function drawAxis() {\n      this.drawLabelsX();\n      this.drawLabelsY();\n    }\n  }, {\n    key: \"drawLabelsX\",\n    value: function drawLabelsX() {\n      var _this = this;\n\n      var labels = store.get(\"labels\");\n      var points = store.get(\"points\", \"line\");\n      var yAxis = Math.floor(this.area.zeroY + cfg.chart.padding / 2); // points & labels are same length\n\n      labels.forEach(function (labelDate, idx) {\n        var xAxis = points[idx][0];\n        var label = utils.fDate(labelDate);\n\n        _this.svgText({\n          point: [xAxis, yAxis],\n          label: label,\n          group: true\n        });\n      });\n    }\n  }, {\n    key: \"drawLabelsY\",\n    value: function drawLabelsY() {\n      var _this2 = this;\n\n      var _cfg$chart = cfg.chart,\n          enableGrid = _cfg$chart.enableGrid,\n          totalGrids = _cfg$chart.totalGrids;\n      var _this$area = this.area,\n          endX = _this$area.endX,\n          gridStep = _this$area.gridStep;\n\n      var _this$calc$yAxis = this.calc.yAxis(),\n          xAxis = _this$calc$yAxis.xAxis,\n          yAxis = _this$calc$yAxis.yAxis,\n          label = _this$calc$yAxis.label,\n          labelDiff = _this$calc$yAxis.labelDiff;\n\n      var gridPath = \"\";\n\n      _toConsumableArray(Array(totalGrids + 1)).forEach(function () {\n        _this2.svgText({\n          point: [xAxis, yAxis],\n          label: label\n        });\n\n        if (enableGrid) {\n          gridPath += _this2.getPath([xAxis, yAxis], [endX, yAxis]);\n        }\n\n        yAxis -= gridStep;\n        label = utils.f(label + labelDiff, 5);\n      });\n\n      enableGrid && this.svgPath(gridPath, \"grid\");\n    }\n  }, {\n    key: \"drawLine\",\n    value: function drawLine() {\n      var points = store.get(\"points\", \"line\");\n      this.svgPath(this.getPathFromPoints(points), \"line\");\n    }\n    /**\r\n     * getPathFromPoints\r\n     * @param {Array} points - axis points\r\n     * @returns {String} path\r\n     */\n\n  }, {\n    key: \"getPathFromPoints\",\n    value: function getPathFromPoints(points) {\n      var idx = 0,\n          path = \"\",\n          len = points.length - 1;\n\n      for (; idx < len; idx++) {\n        path += this.getPath(points[idx], points[idx + 1]);\n        this.svgDebug(points[idx]);\n      }\n\n      return path;\n    }\n  }, {\n    key: \"getPath\",\n    value: function getPath(point1, point2) {\n      var path = \"M\".concat(Math.floor(point1[0]), \" \").concat(Math.floor(point1[1]));\n      path += \"L\".concat(Math.floor(point2[0]), \" \").concat(Math.floor(point2[1]));\n      return path;\n    } //if method have svg prefix depend on svg\n\n  }, {\n    key: \"svgDebug\",\n    value: function svgDebug() {\n      var point = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      if (cfg.debug) {\n        this.svgCircle(point);\n      }\n    }\n  }, {\n    key: \"svgCircle\",\n    value: function svgCircle(point) {\n      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"debug\";\n      var circleElem = this.snap.circle({\n        cx: point[0],\n        cy: point[1],\n        r: 3\n      });\n\n      if (type === \"cursor\") {\n        circleElem.attr({\n          fill: \"#\".concat(cfg.colors[type].fill),\n          strokeWidth: 9,\n          stroke: \"#\".concat(cfg.colors[type].stroke),\n          id: \"liveCursor\"\n        });\n      } else if (type === \"liveNav\") {\n        circleElem.attr({\n          \"class\": \"liveNav\",\n          r: 10\n        }); // display: \"none\"\n      }\n\n      this.group.add(circleElem);\n      return circleElem;\n    } //x,y,width,height\n    // candles are in two groups : candleWin & candleLose\n\n  }, {\n    key: \"svgRect\",\n    value: function svgRect(rectData) {\n      var rectType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      this.cgroup || (this.cgroup = {}); // cgroup - for show/hide candle charts\n\n      if (!this.cgroup[rectType]) {\n        this.cgroup[rectType] = this.snap.group(this.snap.rect(rectData));\n        this.cgroup[rectType].attr({\n          stroke: \"#\".concat(cfg.colors[rectType]),\n          fill: \"#\".concat(cfg.colors[rectType]),\n          id: rectType\n        });\n      } else {\n        this.cgroup[rectType].add(this.snap.rect(rectData));\n      } // nested group\n\n\n      this.group.add(this.cgroup[rectType]);\n    }\n  }, {\n    key: \"svgText\",\n    value: function svgText(_ref) {\n      var point = _ref.point,\n          label = _ref.label,\n          group = _ref.group;\n      var elemId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var textElem = this.snap.text(point[0] - 5, point[1], label);\n      elemId && textElem.attr({\n        id: elemId\n      });\n      group && this.group.add(textElem);\n      return textElem;\n    }\n  }, {\n    key: \"svgLine\",\n    value: function svgLine(point, point1) {\n      var _this$snap;\n\n      return (_this$snap = this.snap).line.apply(_this$snap, _toConsumableArray(point).concat(_toConsumableArray(point1))).attr({\n        stroke: \"#\".concat(cfg.colors.lline),\n        strokeWidth: 5,\n        \"class\": \"liveLine\"\n      });\n    }\n  }, {\n    key: \"svgPath\",\n    value: function svgPath(path) {\n      var pathType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"line\";\n      var svg = this.snap.path(path).attr({\n        stroke: \"#\".concat(cfg.colors[pathType])\n      });\n\n      if (pathType === \"candleWin\" || pathType === \"candleLose\") {\n        this.cgroup[pathType].add(svg);\n      } else {\n        svg.attr({\n          id: pathType\n        });\n      }\n\n      if (pathType === \"grid\") {\n        svg.attr({\n          \"stroke-dasharray\": \"5,10\"\n        });\n      }\n\n      this.group.add(svg);\n    }\n  }, {\n    key: \"toBase64\",\n    value: function toBase64() {\n      var svg64 = new XMLSerializer().serializeToString(this.el);\n      svg64 = btoa(svg64);\n      return \"data:image/svg+xml;base64,\" + svg64;\n    }\n    /**\r\n     * liveMove\r\n     * - fire callback with 3 states = start, move, end\r\n     * - one click activate mouseMove bind to whole svg\r\n     * @param {Function} cb - callback\r\n     */\n\n  }, {\n    key: \"liveMove\",\n    value: function liveMove(cb) {\n      var _this3 = this;\n\n      var click = 0;\n\n      var _store$get = store.get(\"area\"),\n          offsetLeft = _store$get.offsetLeft,\n          offsetTop = _store$get.offsetTop;\n\n      this.snap.unclick();\n      this.snap.click(function (e, x, y) {\n        console.log(\"click\");\n        var point = [x - offsetLeft, y - offsetTop];\n        !click && cb(\"start\", point);\n        click++;\n\n        if (click === 1) {\n          _this3.snap.unmousemove();\n\n          _this3.snap.mousemove(function (e, dx, dy) {\n            if (!(dx % 5)) {\n              var point2 = [dx - offsetLeft, dy - offsetTop];\n              cb(\"move\", point2);\n            }\n          });\n        } else if (click === 2) {\n          _this3.snap.unclick();\n\n          _this3.snap.unmousemove();\n\n          cb(\"end\");\n        }\n      });\n    }\n  }, {\n    key: \"getId\",\n    value: function getId(elemId) {\n      return document.getElementById(elemId);\n    }\n  }]);\n\n  return ChartBase;\n}();\n\nmodule.exports = ChartBase;\n\n//# sourceURL=webpack://Lines/./lib/chart-base.js?");

/***/ }),

/***/ "./lib/chart-plus.js":
/*!***************************!*\
  !*** ./lib/chart-plus.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar store = __webpack_require__(/*! ./store */ \"./lib/store.js\");\n\nvar utils = __webpack_require__(/*! ./utils */ \"./lib/utils.js\");\n\nvar ChartBase = __webpack_require__(/*! ./chart-base */ \"./lib/chart-base.js\");\n\nvar ChartPlus =\n/*#__PURE__*/\nfunction (_ChartBase) {\n  _inherits(ChartPlus, _ChartBase);\n\n  function ChartPlus() {\n    _classCallCheck(this, ChartPlus);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ChartPlus).apply(this, arguments));\n  }\n\n  _createClass(ChartPlus, [{\n    key: \"drawCandle\",\n    value: function drawCandle() {\n      var _this = this;\n\n      var candle = this.getCandle();\n      candle.body.forEach(function (candle) {\n        var candleClass = candle.isWin ? \"candleWin\" : \"candleLose\";\n        delete candle.isWin;\n\n        _this.svgRect(candle, candleClass);\n      });\n      candle.shadow.forEach(function (shadow) {\n        var shadowPath = _this.getPathFromPoints(shadow.top);\n\n        shadowPath += _this.getPathFromPoints(shadow.bottom);\n\n        _this.svgPath(shadowPath, shadow.isWin ? \"candleWin\" : \"candleLose\");\n      });\n    }\n  }, {\n    key: \"getCandle\",\n    value: function getCandle() {\n      var candlePoints = store.get(\"points\", \"candle\");\n      var candle = {\n        body: [],\n        shadow: []\n      };\n      candlePoints.forEach(function (cpoint) {\n        candle.body.push(utils.candle(cpoint));\n        candle.shadow.push(utils.candle(cpoint, \"shadow\"));\n      });\n      return candle;\n    }\n  }]);\n\n  return ChartPlus;\n}(ChartBase);\n\nmodule.exports = ChartPlus;\n\n//# sourceURL=webpack://Lines/./lib/chart-plus.js?");

/***/ }),

/***/ "./lib/chart.js":
/*!**********************!*\
  !*** ./lib/chart.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar store = __webpack_require__(/*! ./store */ \"./lib/store.js\");\n\nvar ChartPlus = __webpack_require__(/*! ./chart-plus */ \"./lib/chart-plus.js\");\n\nvar Chart =\n/*#__PURE__*/\nfunction (_ChartPlus) {\n  _inherits(Chart, _ChartPlus);\n\n  function Chart() {\n    _classCallCheck(this, Chart);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Chart).apply(this, arguments));\n  }\n\n  _createClass(Chart, [{\n    key: \"drawSma\",\n    value: function drawSma() {\n      var points = store.get(\"points\", \"sma\");\n      this.svgPath(this.getPathFromPoints(points), \"sma\");\n    }\n  }, {\n    key: \"drawEma\",\n    value: function drawEma() {\n      var points = store.get(\"points\", \"ema\");\n      this.svgPath(this.getPathFromPoints(points), \"ema\");\n    } /////// New features ...\n\n  }, {\n    key: \"getImage\",\n    value: function getImage() {\n      var _store$get = store.get(\"area\"),\n          w = _store$get.w,\n          h = _store$get.h;\n\n      var imgElem = document.createElement(\"img\");\n      imgElem.setAttribute(\"src\", this.toBase64());\n      imgElem.setAttribute(\"width\", w);\n      imgElem.setAttribute(\"height\", h);\n      return imgElem;\n    } // candle have two groups - candleWin & candleLose\n\n  }, {\n    key: \"toggle\",\n    value: function toggle(chartType) {\n      var chartElem2 = false;\n\n      if (chartType === \"candle\") {\n        chartType = \"candleWin\";\n        chartElem2 = this.getId(\"candleLose\");\n      }\n\n      var chartElem = this.getId(chartType);\n\n      if (!chartElem.style.display || chartElem.style.display === \"block\") {\n        chartElem.style.display = \"none\";\n        chartElem2 && (chartElem2.style.display = \"none\");\n      } else {\n        chartElem.style.display = \"block\";\n        chartElem2 && (chartElem2.style.display = \"block\");\n      }\n    }\n  }, {\n    key: \"cursor\",\n    value: function cursor() {\n      var _this = this;\n\n      if (this.getId(\"liveCursor\")) {\n        this.getId(\"liveCursor\").remove();\n        this.getId(\"liveText\").remove();\n        return;\n      }\n\n      var foundY = this.calc.findY(230);\n      var cursorElem = this.svgCircle([230, foundY.pixel], \"cursor\");\n\n      var _store$mget = store.mget([\"area\", \"zeroX\"]),\n          offsetLeft = _store$mget.area.offsetLeft,\n          zeroX = _store$mget.zeroX;\n\n      var labelElem = this.svgText({\n        point: [zeroX, foundY.pixel],\n        label: foundY.value\n      }, \"liveText\");\n      this.snap.unmousemove();\n      this.snap.mousemove(function (e, x) {\n        x -= offsetLeft;\n\n        if (!(x % 5)) {\n          var findY = _this.calc.findY(x);\n\n          if (findY) {\n            cursorElem.attr({\n              cx: x,\n              cy: findY.pixel\n            });\n            labelElem.node.innerHTML = findY.value;\n            labelElem.attr({\n              y: findY.pixel\n            });\n          }\n        }\n      });\n    }\n  }, {\n    key: \"liveLine\",\n    value: function liveLine() {\n      var _this2 = this;\n\n      var horizontalFLag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var lineElem;\n      this.liveMove(function (state, point) {\n        if (state === \"start\") {\n          lineElem = _this2.svgLine(point, point);\n\n          _this2.svgCircle(point, \"liveNav\");\n        } else if (state === \"move\") {\n          var newPoint = {};\n\n          if (horizontalFLag) {\n            newPoint = {\n              x2: point[0]\n            };\n          } else {\n            newPoint = {\n              x2: point[0],\n              y2: point[1]\n            };\n          }\n\n          lineElem.attr(newPoint);\n        }\n      });\n    }\n  }, {\n    key: \"dragChart\",\n    value: function dragChart() {\n      // this.snap.drag()\n      // this.group.drag((x, y) => {\n      //   console.log(\"... drag : \", x, y, arguments);\n      // });\n      this.group.drag(function (dx, dy) {\n        console.log(\"draggg \");\n\n        if (!(dx % 20)) {\n          console.log(\"draggg & draw missing xAxis labels ...\"); // like tradingView\n\n          this.attr({\n            transform: this.data(\"origTransform\") + (this.data(\"origTransform\") ? \"T\" : \"t\") + [dx]\n          });\n        }\n      }, function () {\n        this.data('origTransform', this.transform().local);\n      }); //   dragX = moveX;\n      //   self.lcGroup.attr({ transform: \"t\" + (dragX + self.dragX) });\n      // }, () => {}, () => {\n      //   self.dragX += dragX;\n      // });\n    }\n  }]);\n\n  return Chart;\n}(ChartPlus);\n\nmodule.exports = Chart;\n\n//# sourceURL=webpack://Lines/./lib/chart.js?");

/***/ }),

/***/ "./lib/config.js":
/*!***********************!*\
  !*** ./lib/config.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n *  EXPORT :\r\n *  config, { TYPES, PARTS }\r\n */\nvar config = {\n  debug: false,\n  animate: false,\n  zoomMove: true,\n  chart: {\n    type: [\"line\", \"candle\", \"sma\", \"ema\"],\n    padding: 30,\n    attr: {\n      stroke: \"#ddd\",\n      fill: \"none\",\n      strokeWidth: 1\n    },\n    textAttr: {\n      \"stroke-width\": \"0.1px\",\n      \"font-family\": \"Verdana\",\n      \"font-size\": \"12px\",\n      fill: \"#000\"\n    },\n    textBold: {\n      \"font-weight\": \"bold\"\n    },\n    enableGrid: true,\n    candleFill: 0.4,\n    totalGrids: 5,\n    navDot: 6,\n    // radius\n    candleFields: {\n      body: [\"x\", \"y\", \"width\", \"height\"],\n      shadow: []\n    }\n  },\n  colors: {\n    candleWin: \"f00\",\n    candleLose: \"00f\",\n    grid: \"ddd\",\n    line: \"36a2eb\",\n    sma: \"ff9f40\",\n    ema: \"9966ff\",\n    cursor: {\n      fill: \"388E3C\",\n      stroke: \"00bcd480\"\n    },\n    lline: \"505050\"\n  },\n  smaLength: 5,\n  emaLength: 10,\n  magnetMode: 50,\n  step: {\n    x: 50,\n    xMin: 20,\n    xMax: 100,\n    yMax: 20,\n    arrow: 50,\n    zoom: 9,\n    offset: 9,\n    xLegend: 100\n  },\n  timeUnit: \"15m\",\n  timeUnits: [\"15m\", \"30m\", \"1h\", \"4h\", \"1d\", \"1w\"],\n  //supported TIME UNITS\n  drawOrder: [\"drawLine\", \"drawCandle\", \"drawSMA\", \"drawEMA\"]\n}; // chart SVG\n\nvar SVG = {\n  line: \"line\",\n  text: \"text\",\n  rect: \"rect\",\n  circle: \"circle\",\n  path: \"path\",\n  input: \"input\"\n}; // // chart Parts\n\nvar PART = {\n  axis: \"axis\",\n  line: \"line\",\n  candle: \"candle\",\n  legend: \"legend\",\n  debug: \"debug\",\n  sinit: \"sinit\",\n  init: \"init\",\n  sma: \"sma\",\n  ema: \"ema\"\n};\nmodule.exports = {\n  config: config,\n  SVG: SVG,\n  PART: PART\n};\n\n//# sourceURL=webpack://Lines/./lib/config.js?");

/***/ }),

/***/ "./lib/index.js":
/*!**********************!*\
  !*** ./lib/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var store = __webpack_require__(/*! ./store */ \"./lib/store.js\");\n\nvar Calc = __webpack_require__(/*! ./calc */ \"./lib/calc.js\");\n\nvar Chart = __webpack_require__(/*! ./chart */ \"./lib/chart.js\");\n\nvar _require = __webpack_require__(/*! ./config */ \"./lib/config.js\"),\n    PART = _require.PART,\n    cfg = _require.config;\n/**\r\n * Only public methods here\r\n *  - everething else should be splited into other files\r\n *  - store.js - GLOBAL STORE\r\n *  - calc.js - calculation\r\n *  - chart.js - SVG line layer\r\n *  - candle.js - SVG candle layer\r\n *  - config.js - configuration\r\n */\n\n\nvar Lines = function () {\n  var Lines = function Lines(elemId) {\n    if (!window.Snap) {\n      throw new Error(\"Missing Snap.svg library !\");\n    }\n\n    this.calc = new Calc(); // chart-base > chart-plus > chart\n    // pass instance of calc to chart ...\n\n    this.chart = new Chart(elemId, this.calc);\n  };\n  /**\r\n   * public Method\r\n   *  - save data into store ...\r\n   * @param {Array} chartData\r\n   */\n\n\n  Lines.prototype.data = function (chartData) {\n    if (!(chartData instanceof Array)) {\n      throw new Error(\"Missing library  data !\");\n    }\n\n    store.save(chartData);\n    this.calc.start(); // lines ... candles ...\n\n    this.calc.main();\n  };\n  /*\r\n                        _                            _   _               _     \r\n     _ __ ___ _ __   __| | ___ _ __   _ __ ___   ___| |_| |__   ___   __| |___ \r\n    | '__/ _ \\ '_ \\ / _` |/ _ \\ '__| | '_ ` _ \\ / _ \\ __| '_ \\ / _ \\ / _` / __|\r\n    | | |  __/ | | | (_| |  __/ |    | | | | | |  __/ |_| | | | (_) | (_| \\__ \\\r\n    |_|  \\___|_| |_|\\__,_|\\___|_|    |_| |_| |_|\\___|\\__|_| |_|\\___/ \\__,_|___/\r\n  */\n\n\n  Lines.prototype.draw = function (chartType) {\n    switch (chartType) {\n      case PART.axis:\n        this.chart.drawAxis();\n        break;\n\n      case PART.line:\n        this.chart.drawLine();\n        break;\n\n      case PART.candle:\n        this.chart.drawCandle();\n        break;\n\n      case PART.sma:\n        this.chart.drawSma();\n        break;\n\n      case PART.ema:\n        this.chart.drawEma();\n        break;\n\n      default:\n        this.chart.drawAxis();\n        this.chart.drawLine();\n        this.chart.drawCandle();\n        this.chart.drawSma();\n        this.chart.drawEma();\n        this.chart.dragChart();\n    }\n  };\n\n  Lines.prototype.getImage = function () {\n    return this.chart.getImage();\n  }; // show/hide chart: line, candle, sma, ema\n\n\n  Lines.prototype.toggle = function (chartType) {\n    if (cfg.chart.type.includes(chartType)) {\n      this.chart.toggle(chartType);\n    }\n  }; // live Dot - ldot\n\n\n  Lines.prototype.cursor = function () {\n    this.chart.cursor();\n  }; // allow to draw Line ...\n\n\n  Lines.prototype.live = function () {\n    var drawType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"line\";\n    this.chart.liveLine();\n  };\n\n  return Lines;\n}();\n\nif ( true && typeof module.exports !== \"undefined\") {\n  module.exports = Lines;\n} else {\n  window.Lines = Lines;\n}\n\n//# sourceURL=webpack://Lines/./lib/index.js?");

/***/ }),

/***/ "./lib/store.js":
/*!**********************!*\
  !*** ./lib/store.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar store = {}; // internal STORE\n\nvar _store = {\n  init: {},\n  line: {},\n  candle: {},\n  ema: {},\n  sma: {},\n  _live: {},\n\n  set live(liveVal) {\n    this._live = liveVal;\n  },\n\n  get live() {\n    return this._live;\n  }\n\n};\n\nvar _blank = _objectSpread({}, _store);\n\nstore.save = function (saveData) {\n  var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"line\";\n  var validData = store.validate(saveData) ? saveData : store.dataFormatter(saveData);\n  store.mset({\n    raw: validData,\n    labels: validData.map(function (item) {\n      return item[4];\n    }),\n    data: validData.map(function (item) {\n      return item[3];\n    })\n  }); // redundant data because it is present into init \n\n  store.set(\"data\", validData.map(function (item) {\n    return item[3];\n  }), \"line\");\n}; //toDO remove this ...\n\n\nstore.all = function () {\n  return _store;\n}; //getter\n\n\nstore.get = function (getProp) {\n  var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"init\";\n  return _store[scope][getProp];\n}; //multi getter\n\n\nstore.mget = function (getProps) {\n  var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"init\";\n  var _data = {};\n  getProps.forEach(function (prop) {\n    _data[prop] = _store[scope][prop];\n  });\n  return _data;\n}; // check and init\n// candle.points = level1 candle & level2 points\n\n\nstore.init = function (prop) {\n  var _prop$split = prop.split(\".\"),\n      _prop$split2 = _slicedToArray(_prop$split, 2),\n      level1 = _prop$split2[0],\n      level2 = _prop$split2[1];\n\n  if (level2) {\n    !_store[level1] && (_store[level1] = {});\n    !_store[level1][level2] && (_store[level1][level2] = []);\n  } else {\n    !_store[level1] && (_store[level1] = []);\n  }\n\n  return level2 ? [level1, level2] : [level1];\n}; // push to array\n// chart.property - level1 chart & level2 propery\n\n\nstore.push = function (pushProp, pushData) {\n  var levels = store.init(pushProp);\n\n  if (levels[1]) {\n    _store[levels[0]][levels[1]].push(pushData);\n  } else {\n    _store[levels[0]].push(pushData);\n  }\n}; // setter\n\n\nstore.set = function (setProp, setData) {\n  var scope = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"init\";\n  _store[scope][setProp] = setData;\n}; // multi setter - {prop1: prop1_value, prop2: pro2_value}\n\n\nstore.mset = function (setData) {\n  var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"init\";\n  _store[scope] = _objectSpread({}, _store[scope], {}, setData);\n};\n/**\r\n * check if all array members have date & high properties\r\n * array.every - return boolean ( true | false )\r\n */\n\n\nstore.validate = function (dataArray) {\n  return dataArray.every(function (item) {\n    return !item.date || !item.high;\n  });\n};\n\nstore.dataFormatter = function (rawData) {\n  return rawData.map(function (row) {\n    return [row.open, row.high, row.low, row.close, row.date];\n  });\n};\n\nstore.reset = function () {\n  _store = _objectSpread({}, _blank);\n};\n\nmodule.exports = _objectSpread({}, store);\n\n//# sourceURL=webpack://Lines/./lib/store.js?");

/***/ }),

/***/ "./lib/utils.js":
/*!**********************!*\
  !*** ./lib/utils.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nmodule.exports = function () {\n  var utils = {}; //formater\n\n  utils.f = function (_number) {\n    var fixDigit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;\n    return Math.abs(parseFloat(_number).toFixed(fixDigit));\n  };\n\n  utils.fDate = function (timeStamp) {\n    var period = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"15m\";\n    var date = new Date(timeStamp); // (\"3123\" + d.getMinutes()).slice(-4)\n\n    if (period === \"15m\") {\n      return date.getHours() + \":\" + date.getMinutes();\n    }\n  };\n\n  utils.candle = function (candlePoint) {\n    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"body\";\n    var allowedFields = {\n      body: [\"x\", \"y\", \"width\", \"height\", \"isWin\"],\n      shadow: [\"top\", \"bottom\", \"isWin\"]\n    };\n    return Object.keys(candlePoint).filter(function (key) {\n      return allowedFields[type].includes(key);\n    }).reduce(function (obj, key) {\n      obj[key] = candlePoint[key];\n      return obj;\n    }, {});\n  };\n\n  return _objectSpread({}, utils);\n}();\n\n//# sourceURL=webpack://Lines/./lib/utils.js?");

/***/ })

/******/ });
});